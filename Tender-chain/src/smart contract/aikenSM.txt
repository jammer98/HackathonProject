// Government Tender System - Aiken Smart Contract
// Cardano blockchain-based anti-corruption tender system

use aiken/hash.{Blake2b_224, Hash}
use aiken/transaction.{ScriptContext, Spend, Transaction}
use aiken/transaction/credential.{Address, VerificationKeyCredential}
use aiken/transaction/value.{lovelace_of}
use aiken/list
use aiken/dict.{Dict}
use aiken/interval.{Finite}

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// Bidder registration information
pub type BidderInfo {
  bidder_address: Address,
  bidder_name: ByteArray,
  bidder_contact: ByteArray,
  bidder_email: ByteArray,
  company_name: ByteArray,
  registration_date: Int,
  is_verified: Bool,
}

// Individual part of a tender project
pub type ProjectPart {
  part_id: Int,
  part_name: ByteArray,
  part_description: ByteArray,
  threshold_amount: Int,      // Maximum bid amount in lovelace
  minimum_bid_amount: Int,    // 80% of threshold
  estimated_time: Int,        // in days
}

// Bid status enumeration
pub type BidStatus {
  Submitted
  InTop20
  Selected
  Rejected
}

// Bid submitted by a bidder
pub type Bid {
  bid_id: ByteArray,
  bidder_id: Address,
  project_id: ByteArray,
  part_bids: List<PartBid>,   // Bid for each part
  total_amount: Int,          // Total bid amount in lovelace
  total_time: Int,            // Total time in days
  time_cost_ratio: Int,       // (total_time * 1000000) / total_amount
  bid_timestamp: Int,
  bid_status: BidStatus,
}

// Bid for individual part
pub type PartBid {
  part_id: Int,
  bid_amount: Int,            // in lovelace
  proposed_time: Int,         // in days
}

// Project status enumeration
pub type ProjectStatus {
  Open                        // Accepting bids
  UnderReview                 // Top 20 selected, offline review
  Awarded                     // Contract awarded
  InProgress                  // Work in progress
  Completed                   // Project completed
  Cancelled                   // Project cancelled
}

// Complete tender project
pub type TenderProject {
  project_id: ByteArray,
  project_name: ByteArray,
  project_description: ByteArray,
  issuing_authority: Address, // Government officer who created
  project_parts: List<ProjectPart>,
  issue_date: Int,
  deadline: Int,              // Bidding deadline timestamp
  project_status: ProjectStatus,
}

// Payment status enumeration
pub type PaymentStatus {
  Pending
  PartialPaid { amount_paid: Int }
  FullyPaid
  Disputed
}

// Award details for winning bid
pub type AwardDetails {
  award_id: ByteArray,
  awarded_project_id: ByteArray,
  winning_bidder_id: Address,
  winning_bid_id: ByteArray,
  final_amount: Int,
  final_timeline: Int,
  awarded_by: Address,        // Government officer who finalized
  award_date: Int,
  payment_status: PaymentStatus,
  milestones: List<Milestone>,
}

// Milestone for payment tracking
pub type Milestone {
  milestone_id: Int,
  description: ByteArray,
  percentage: Int,            // Percentage of total amount
  amount: Int,                // Calculated amount
  is_paid: Bool,
  paid_date: Option<Int>,
}

// Payment record
pub type PaymentRecord {
  payment_id: ByteArray,
  award_reference: ByteArray,
  milestone_id: Int,
  payment_amount: Int,
  payment_date: Int,
  paid_by: Address,           // Government
  received_by: Address,       // Bidder
  transaction_hash: ByteArray,
}

// ============================================================================
// CONTRACT STATE (DATUM)
// ============================================================================

pub type TenderSystemDatum {
  admin_address: Address,
  authorized_officers: List<Address>,
  
  // Core mappings
  all_bidders: Dict<Address, BidderInfo>,
  all_projects: Dict<ByteArray, TenderProject>,
  all_bids: Dict<ByteArray, Bid>,
  all_awards: Dict<ByteArray, AwardDetails>,
  all_payments: Dict<ByteArray, PaymentRecord>,
  
  // Relationship mappings for easy frontend queries
  bids_by_project: Dict<ByteArray, List<ByteArray>>,    // projectId -> [bidIds]
  bids_by_bidder: Dict<Address, List<ByteArray>>,       // bidderAddr -> [bidIds]
  projects_by_authority: Dict<Address, List<ByteArray>>, // authority -> [projectIds]
  awards_by_project: Dict<ByteArray, List<ByteArray>>,  // projectId -> [awardIds]
  awards_by_bidder: Dict<Address, List<ByteArray>>,     // bidderAddr -> [awardIds]
  payments_by_award: Dict<ByteArray, List<ByteArray>>,  // awardId -> [paymentIds]
  
  // Lists for discovery
  open_project_ids: List<ByteArray>,
  all_project_ids: List<ByteArray>,
}

// ============================================================================
// CONTRACT ACTIONS (REDEEMER)
// ============================================================================

pub type TenderAction {
  // Admin actions
  AuthorizeOfficer { officer: Address }
  RevokeOfficer { officer: Address }
  
  // Bidder actions
  RegisterBidder { bidder_info: BidderInfo }
  VerifyBidder { bidder_address: Address }
  
  // Government actions
  CreateProject { project: TenderProject }
  UpdateProjectStatus { project_id: ByteArray, status: ProjectStatus }
  
  // Bidding actions
  SubmitBid { bid: Bid }
  WithdrawBid { bid_id: ByteArray }
  
  // Shortlisting (off-chain calculated, on-chain verified)
  SelectTop20 { project_id: ByteArray, top_bid_ids: List<ByteArray> }
  
  // Award actions
  AwardContract { award: AwardDetails }
  
  // Payment actions
  MakePayment { payment: PaymentRecord }
  UpdatePaymentStatus { award_id: ByteArray, status: PaymentStatus }
}

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

validator {
  fn tender_system(datum: TenderSystemDatum, redeemer: TenderAction, ctx: ScriptContext) {
    let tx = ctx.transaction
    
    when redeemer is {
      // -----------------------------------------------------------------------
      // ADMIN ACTIONS
      // -----------------------------------------------------------------------
      AuthorizeOfficer { officer } -> {
        // Only admin can authorize officers
        expect_signed_by_admin(datum, tx) &&
        // Officer not already authorized
        !list.has(datum.authorized_officers, officer)
      }
      
      RevokeOfficer { officer } -> {
        // Only admin can revoke officers
        expect_signed_by_admin(datum, tx) &&
        // Cannot revoke admin
        officer != datum.admin_address &&
        // Officer must be authorized
        list.has(datum.authorized_officers, officer)
      }
      
      // -----------------------------------------------------------------------
      // BIDDER REGISTRATION
      // -----------------------------------------------------------------------
      RegisterBidder { bidder_info } -> {
        // Bidder not already registered
        !dict.has_key(datum.all_bidders, bidder_info.bidder_address) &&
        // Valid bidder information
        validate_bidder_info(bidder_info) &&
        // Signed by the bidder
        list.has(tx.extra_signatories, extract_key_hash(bidder_info.bidder_address))
      }
      
      VerifyBidder { bidder_address } -> {
        // Only admin or authorized officer can verify
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Bidder must be registered
        dict.has_key(datum.all_bidders, bidder_address)
      }
      
      // -----------------------------------------------------------------------
      // PROJECT CREATION
      // -----------------------------------------------------------------------
      CreateProject { project } -> {
        // Only authorized officers can create projects
        expect_signed_by_officer(datum, tx) &&
        // Project doesn't exist
        !dict.has_key(datum.all_projects, project.project_id) &&
        // Valid project data
        validate_project(project) &&
        // Issuing authority is the signer
        list.has(tx.extra_signatories, extract_key_hash(project.issuing_authority)) &&
        // Deadline is in the future
        project.deadline > project.issue_date
      }
      
      UpdateProjectStatus { project_id, status } -> {
        // Only admin or authorized officer
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Project exists
        dict.has_key(datum.all_projects, project_id) &&
        // Valid status transition
        validate_status_transition(datum, project_id, status)
      }
      
      // -----------------------------------------------------------------------
      // BIDDING
      // -----------------------------------------------------------------------
      SubmitBid { bid } -> {
        // Bidder is registered and verified
        expect when dict.get(datum.all_bidders, bid.bidder_id) is {
          Some(bidder) -> bidder.is_verified
          None -> False
        } &&
        // Project exists and is open
        expect when dict.get(datum.all_projects, bid.project_id) is {
          Some(project) -> 
            when project.project_status is {
              Open -> True
              _ -> False
            }
          None -> False
        } &&
        // Bid doesn't already exist
        !dict.has_key(datum.all_bids, bid.bid_id) &&
        // Validate bid amounts against thresholds
        validate_bid_amounts(datum, bid) &&
        // Deadline not passed
        validate_deadline(datum, bid, ctx) &&
        // Signed by bidder
        list.has(tx.extra_signatories, extract_key_hash(bid.bidder_id))
      }
      
      WithdrawBid { bid_id } -> {
        expect when dict.get(datum.all_bids, bid_id) is {
          Some(bid) -> {
            // Can only withdraw own bids
            list.has(tx.extra_signatories, extract_key_hash(bid.bidder_id)) &&
            // Can only withdraw if not yet shortlisted
            when bid.bid_status is {
              Submitted -> True
              _ -> False
            }
          }
          None -> False
        }
      }
      
      // -----------------------------------------------------------------------
      // SHORTLISTING (Off-chain calculated, on-chain verified)
      // -----------------------------------------------------------------------
      SelectTop20 { project_id, top_bid_ids } -> {
        // Only admin or officer
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Project exists
        dict.has_key(datum.all_projects, project_id) &&
        // Exactly 20 or fewer bids (if less than 20 total bids)
        list.length(top_bid_ids) <= 20 &&
        // All bid IDs are valid for this project
        validate_top20_bids(datum, project_id, top_bid_ids)
      }
      
      // -----------------------------------------------------------------------
      // AWARD CONTRACT
      // -----------------------------------------------------------------------
      AwardContract { award } -> {
        // Only admin or officer
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Award doesn't exist
        !dict.has_key(datum.all_awards, award.award_id) &&
        // Winning bid exists and is in top 20
        expect when dict.get(datum.all_bids, award.winning_bid_id) is {
          Some(bid) -> 
            when bid.bid_status is {
              InTop20 -> True
              _ -> False
            }
          None -> False
        } &&
        // Valid award details
        validate_award(award) &&
        // Signed by awarding officer
        list.has(tx.extra_signatories, extract_key_hash(award.awarded_by))
      }
      
      // -----------------------------------------------------------------------
      // PAYMENTS
      // -----------------------------------------------------------------------
      MakePayment { payment } -> {
        // Only admin or officer
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Award exists
        expect when dict.get(datum.all_awards, payment.award_reference) is {
          Some(award) -> {
            // Milestone exists and not yet paid
            validate_milestone_payment(award, payment) &&
            // Payment amount matches
            payment.payment_amount > 0 &&
            // Actual ADA transfer in transaction
            validate_payment_output(tx, payment)
          }
          None -> False
        }
      }
      
      UpdatePaymentStatus { award_id, status } -> {
        // Only admin or officer
        (expect_signed_by_admin(datum, tx) || 
         expect_signed_by_officer(datum, tx)) &&
        // Award exists
        dict.has_key(datum.all_awards, award_id)
      }
    }
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn expect_signed_by_admin(datum: TenderSystemDatum, tx: Transaction) -> Bool {
  list.has(tx.extra_signatories, extract_key_hash(datum.admin_address))
}

fn expect_signed_by_officer(datum: TenderSystemDatum, tx: Transaction) -> Bool {
  list.any(
    datum.authorized_officers,
    fn(officer) { list.has(tx.extra_signatories, extract_key_hash(officer)) }
  )
}

fn extract_key_hash(addr: Address) -> Hash<Blake2b_224, VerificationKey> {
  expect VerificationKeyCredential(key_hash) = addr.payment_credential
  key_hash
}

fn validate_bidder_info(bidder: BidderInfo) -> Bool {
  // Name not empty
  !builtin.null_list(bidder.bidder_name) &&
  // Contact not empty
  !builtin.null_list(bidder.bidder_contact) &&
  // Email not empty
  !builtin.null_list(bidder.bidder_email) &&
  // Company name not empty
  !builtin.null_list(bidder.company_name)
}

fn validate_project(project: TenderProject) -> Bool {
  // Project ID not empty
  !builtin.null_list(project.project_id) &&
  // Project name not empty
  !builtin.null_list(project.project_name) &&
  // Has at least one part
  list.length(project.project_parts) > 0 &&
  // All parts are valid
  list.all(
    project.project_parts,
    fn(part) {
      part.threshold_amount > 0 &&
      part.minimum_bid_amount > 0 &&
      part.minimum_bid_amount <= part.threshold_amount &&
      part.estimated_time > 0
    }
  )
}

fn validate_bid_amounts(datum: TenderSystemDatum, bid: Bid) -> Bool {
  expect when dict.get(datum.all_projects, bid.project_id) is {
    Some(project) -> {
      // Check each part bid against project thresholds
      list.all(
        bid.part_bids,
        fn(part_bid) {
          expect when list.find(
            project.project_parts,
            fn(p) { p.part_id == part_bid.part_id }
          ) is {
            Some(project_part) -> {
              part_bid.bid_amount >= project_part.minimum_bid_amount &&
              part_bid.bid_amount <= project_part.threshold_amount &&
              part_bid.proposed_time > 0
            }
            None -> False
          }
        }
      )
    }
    None -> False
  }
}

fn validate_deadline(datum: TenderSystemDatum, bid: Bid, ctx: ScriptContext) -> Bool {
  expect when dict.get(datum.all_projects, bid.project_id) is {
    Some(project) -> {
      // Get current time from transaction validity range
      expect Finite(lower_bound) = ctx.transaction.validity_range.lower_bound.bound_type
      lower_bound <= project.deadline
    }
    None -> False
  }
}

fn validate_status_transition(
  datum: TenderSystemDatum,
  project_id: ByteArray,
  new_status: ProjectStatus
) -> Bool {
  expect when dict.get(datum.all_projects, project_id) is {
    Some(project) -> {
      // Valid state transitions
      when (project.project_status, new_status) is {
        (Open, UnderReview) -> True
        (UnderReview, Awarded) -> True
        (UnderReview, Open) -> True
        (Awarded, InProgress) -> True
        (InProgress, Completed) -> True
        (_, Cancelled) -> True
        _ -> False
      }
    }
    None -> False
  }
}

fn validate_top20_bids(
  datum: TenderSystemDatum,
  project_id: ByteArray,
  bid_ids: List<ByteArray>
) -> Bool {
  // All bids exist and belong to this project
  list.all(
    bid_ids,
    fn(bid_id) {
      expect when dict.get(datum.all_bids, bid_id) is {
        Some(bid) -> bid.project_id == project_id
        None -> False
      }
    }
  )
}

fn validate_award(award: AwardDetails) -> Bool {
  // Award ID not empty
  !builtin.null_list(award.award_id) &&
  // Final amount positive
  award.final_amount > 0 &&
  // Final timeline positive
  award.final_timeline > 0 &&
  // Has milestones
  list.length(award.milestones) > 0 &&
  // Milestone percentages sum to 100
  validate_milestones(award.milestones)
}

fn validate_milestones(milestones: List<Milestone>) -> Bool {
  let total_percentage = list.foldr(
    milestones,
    0,
    fn(milestone, acc) { acc + milestone.percentage }
  )
  total_percentage == 100
}

fn validate_milestone_payment(award: AwardDetails, payment: PaymentRecord) -> Bool {
  // Find the milestone
  expect when list.find(
    award.milestones,
    fn(m) { m.milestone_id == payment.milestone_id }
  ) is {
    Some(milestone) -> {
      // Not yet paid
      !milestone.is_paid &&
      // Payment amount matches milestone amount
      payment.payment_amount == milestone.amount
    }
    None -> False
  }
}

fn validate_payment_output(tx: Transaction, payment: PaymentRecord) -> Bool {
  // Check if transaction has output to bidder with correct amount
  list.any(
    tx.outputs,
    fn(output) {
      output.address == payment.received_by &&
      lovelace_of(output.value) >= payment.payment_amount
    }
  )
}

// ============================================================================
// FRONTEND QUERY HELPERS (Off-chain code would use these structures)
// ============================================================================

// These types help organize data for frontend dashboards

pub type BidderDashboardData {
  bidder_info: BidderInfo,
  my_bids: List<Bid>,
  my_awards: List<AwardDetails>,
  my_payments: List<PaymentRecord>,
  available_projects: List<TenderProject>,
}

pub type GovernmentDashboardData {
  my_projects: List<TenderProject>,
  all_bids_by_project: Dict<ByteArray, List<Bid>>,
  awards_issued: List<AwardDetails>,
  payments_issued: List<PaymentRecord>,
  registered_bidders: List<BidderInfo>,
}

pub type ProjectDetailView {
  project_info: TenderProject,
  all_bids: List<Bid>,
  top20_bids: List<Bid>,
  awarded_bid: Option<AwardDetails>,
  total_bids_count: Int,
}